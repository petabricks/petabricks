%{
#include <stdio.h>
#include <map>
#include "ruleir.h"
#include "jconvert.h"
#include "formula.h"

using namespace hecura;

extern int ruleirlineno;

extern int yylex (void);
static int yyerror(const RIRBlockPtr&, const char* msg){ JASSERT(false)(ruleirlineno)(msg).Text("parse error"); return 0;}

static jalib::JRefPool theRefPool;
#define REFALLOC(args...) (theRefPool.add(new args))

static void clearParserCaches(){
  theRefPool.clear();
}

%}

%union {
  const char* str;
  hecura::RIRExpr*  expr;
  hecura::RIRStmt*  stmt;
  hecura::RIRBlock* block;
}

%defines
%locations
%expect 1
%name-prefix="ruleir"
%start Start
%parse-param { hecura::RIRBlockPtr& ret };

%type <str> TOK_OP TOK_LIT TOK_IDENT TOK_RAW
%type <expr> Op
%type <expr> Lit
%type <expr> Ident
%type <expr> ExprElement Expr
%type <expr> Call
%type <expr> Args OptArgs

%type <stmt> Stmt IfStmt LoopStmt BlockStmt RawStmt ReturnStmt
%type <block> Block

%left TOK_OP TOK_LIT TOK_IDENT TOK_IF TOK_THEN TOK_ELSE TOK_FOR TOK_WHILE TOK_DO TOK_RETURN TOK_BREAK TOK_CONTINUE TOK_RAW

%%

Start: Block {
  ret=$1;
}

Block: Block Stmt {($$=$1)->addStmt($2);}
     | Nil        {$$=REFALLOC(RIRBlock());};

Stmt: Expr ';'   {($$=REFALLOC(RIRStmt()))->addExpr($1);}
    | Nil  ';'   {($$=REFALLOC(RIRStmt()));}
    | IfStmt     {$$=$1;}
    | LoopStmt   {$$=$1;}
    | BlockStmt  {$$=$1;}
    | ReturnStmt {$$=$1;}
    | RawStmt    {$$=$1;};

IfStmt: TOK_IF '(' Expr ')' Stmt                {
  $$=REFALLOC(RIRStmt());
  UNIMPLEMENTED();
};

IfStmt: TOK_IF '(' Expr ')' Stmt TOK_ELSE  Stmt {
  $$=REFALLOC(RIRStmt());
  UNIMPLEMENTED();
};

LoopStmt: TOK_FOR '(' Expr ';' Expr ';' Expr ')' Stmt {
  $$=REFALLOC(RIRStmt());
  UNIMPLEMENTED();
};

LoopStmt: TOK_WHILE '(' Expr ')' Stmt {
  $$=REFALLOC(RIRStmt());
  UNIMPLEMENTED();
};

LoopStmt: TOK_DO Stmt TOK_WHILE '(' Expr ')' ';'{
  $$=REFALLOC(RIRStmt());
  UNIMPLEMENTED();
};

BlockStmt: '{' Block '}' {
  $$=REFALLOC(RIRStmt());
  UNIMPLEMENTED();
};

ReturnStmt: TOK_RETURN Expr ';' {
  $$=REFALLOC(RIRReturnStmt());
  $$->addExpr($2);
};

RawStmt: TOK_RAW {
  $$=REFALLOC(RIRStmt());
  UNIMPLEMENTED();
};

Expr: Expr ExprElement     {($$=$1)->addSubExpr($2);}
    | ExprElement          {($$=REFALLOC(RIRChainExpr()))->addSubExpr($1);};

ExprElement: Op    {$$=$1;}
           | Lit   {$$=$1;}
           | Ident {$$=$1;}
           | Call  {$$=$1;};

Call: Ident '(' OptArgs ')'  { 
  $$=REFALLOC(RIRCallExpr()); 
  $$->addSubExpr($1);
  $$->addSubExpr($3);
};


Args: Expr          { ($$=REFALLOC(RIRArgsExpr()))->addSubExpr($1); }
    | Args ',' Expr { ($$=$1)->addSubExpr($3); };

OptArgs: Nil   {$$=REFALLOC(RIRArgsExpr());}
       | Args  {$$=$1;};

Op:    TOK_OP    {$$=REFALLOC(RIROpExpr($1));};
Lit:   TOK_LIT   {$$=REFALLOC(RIRLitExpr($1));};
Ident: TOK_IDENT {$$=REFALLOC(RIRIdentExpr($1));};

Nil:;


%%

void _ruleirlexer_scan_string( const std::string& str);

RIRBlockPtr parseRuleBody(const std::string& str){
  JTRACE("Parsing rule body")(str);
  _ruleirlexer_scan_string(str);
  RIRBlockPtr ret;
  ruleirparse(ret);
  return ret;
}


