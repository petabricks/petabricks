/***************************************************************************
 *  Copyright (C) 2008-2009 Massachusetts Institute of Technology          *
 *                                                                         *
 *  This source code is part of the PetaBricks project and currently only  *
 *  available internally within MIT.  This code may not be distributed     *
 *  outside of MIT. At some point in the future we plan to release this    *
 *  code (most likely GPL) to the public.  For more information, contact:  *
 *  Jason Ansel <jansel@csail.mit.edu>                                     *
 *                                                                         *
 *  A full list of authors may be found in the file AUTHORS.               *
 ***************************************************************************/

#include "codegenerator.h"
#include "maximawrapper.h"
#include "transform.h"

#include "common/jargs.h"
#include "common/jfilesystem.h"
#include "common/jtunable.h"

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif

#ifdef HAVE_OPENCL
#include "openclutil.h"
#endif


#include <fstream>
#include <iostream>
#include <sys/stat.h>
#include <sys/types.h>

const char headertxth[] = 
  "// Generated by " PACKAGE " compiler (pbc) v" VERSION " " REVISION_LONG "\n"
  "#include \"petabricks.h\"\n"
  "#ifdef __GNUC__\n"
  "#pragma GCC diagnostic ignored \"-Wunused-variable\"\n"
  "#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n"
  "#pragma GCC diagnostic ignored \"-Wunused-value\"\n"
  "#endif\n"
  "using namespace petabricks;\n\n"
  ;

const char headertxtcpp[] = 
  "// Generated by " PACKAGE " compiler (pbc) v" VERSION " " REVISION_LONG "\n"
  "#include \""GENHEADER"\"\n"
  ;


void callCxxCompiler();
std::string cmdCxxCompiler();

using namespace petabricks;


namespace pbcConfig {
  bool shouldCompile = true;
  bool shouldLink = true;
  std::string theCommonDir;
  std::string theHardcodedConfig;
  std::string theInput;
  std::string theLibDir;
  std::string theMainName;
  std::string theObjDir;
  std::string theObjectFile;
  std::string theOutputBin;
  std::string theOutputInfo;
  std::string theRuntimeDir;
  std::string thePbPreprocessor;
  int theNJobs = 2;
}
using namespace pbcConfig;

//defined in pbparser.ypp
TransformListPtr parsePbFile(const char* filename);

/* wrapper around popen */
FILE* opensubproc(const std::string& cmd) {
  FILE* p = popen(cmd.c_str(), "r");
  JTRACE("debug ")(cmd);
  JASSERT(p!= 0)(cmd);
  return p;
}

/* wrapper around pclose */
void closesubproc(FILE* p, const std::string& name) {
  std::cerr << name << std::endl;
  while(!feof(p)) {
    char buf[1024];
    memset(buf, 0, sizeof buf);
    (void)fread(buf, 1, sizeof buf -1,  p);
    std::cerr << buf;
  }
  JASSERT(pclose(p)==0);
}


/**
 * Small helper class used to output cpp files and call gcc
 */
class OutputCode {
  std::string   _cpp;
  std::string   _obj;
  StreamTreePtr _code;
  std::string   _gcccmd;
  FILE*         _gccfd;
public:
  OutputCode(const std::string& base, CodeGenerator& o) 
    : _cpp(base+".cpp")
    , _obj(base+".o")
    , _gccfd(0)
  {
    _code = o.startSubfile(base);

    std::ostringstream os; 
    os << CXX " " CXXFLAGS " " CXXDEFS " -c -o " << _obj 
                                      << " "     << _cpp
                                      << " -I\"" << theLibDir << "\""
                                      << " -I\"" << theRuntimeDir << "\""
                                      << " 2>&1";
    _gcccmd = os.str();
  }

  void write() {
    std::ofstream of(_cpp.c_str());
    of << headertxtcpp;
    of << "/* Compile with: \n"
       <<  _gcccmd << "\n"
       << " */\n";
    _code->writeTo(of);
    of.flush();
    of.close();
  }
  
  void forkCompile() {
    _gccfd = opensubproc(_gcccmd);
  }

  void waitCompile() {
    closesubproc(_gccfd, "Compile "+_cpp);
  }

  const std::string& objpath() const { return _obj; }
};


/**
 * Collection of all the output source files of the compiler
 */
class OutputCodeList : public std::vector<OutputCode> {
public:

  void writeHeader(const StreamTreePtr& h) {
    std::ofstream of((theObjDir+"/"GENHEADER).c_str());
    h->writeTo(of);
    of.flush();
    of.close();
  }

  void write() {
    for(iterator i=begin(); i!=end(); ++i)
      i->write();
  }

  void compile() {
    iterator iwrite=begin(), ifork=begin(), iwait=begin();

    JASSERT(theNJobs>=1)(theNJobs);
    for(int i=0; i<theNJobs && iwait!=end(); ++i){
      if(iwrite!=end())
        (iwrite++)->write();
      if(ifork!=end())
        (ifork++)->forkCompile();
    }

    while(iwait!=end()) {
      //invariant: iwrite == ifork > iwait
      if(iwrite!=end())
        (iwrite++)->write();
      if(iwait!=end())
        (iwait++)->waitCompile();
      if(ifork!=end())
        (ifork++)->forkCompile();
    }
    JASSERT(iwrite==end());
    JASSERT(ifork==end());
  }

  std::string mklinkcmd() {
    std::ostringstream os; 
    os << CXX " " CXXFLAGS " -o " << theOutputBin;
    for(const_iterator i=begin(); i!=end(); ++i)
      os << " " << i->objpath();
    os << " " CXXLDFLAGS " -L\"" << theLibDir <<"\" -lpbmain -lpbruntime -lpbcommon " CXXLIBS;
    os << " 2>&1";
    return os.str();
  }

  void link() {
    closesubproc(opensubproc(mklinkcmd()), "Link "+theOutputBin);
  }
};


void findMainTransform(const TransformListPtr& t) {
  //find the main transform if it has not been specified
  if(theMainName==""){
    for(TransformList::const_iterator i=t->begin(); i!=t->end(); ++i){
      if((*i)->isMain()){
        JASSERT(theMainName=="")(theMainName)((*i)->name())
          .Text("Two transforms both have the 'main' keyword");
        theMainName = (*i)->name();
      }
    }
    if(theMainName=="") theMainName = t->back()->name();
  }
}

int main( int argc, const char ** argv){

  /*
  #ifdef HAVE_OPENCL
  OpenCLUtil::init();
  OpenCLUtil::printDeviceList();
  OpenCLUtil::deinit();
  exit(-1);
  #endif
  */

  // READ COMMAND LINE:

  OutputCodeList ccfiles;

  jalib::JArgs args(argc, argv);
  std::vector<std::string> inputs;
  if(args.needHelp())
    std::cerr << "OPTIONS:" << std::endl;
  
  thePbPreprocessor="\""PYTHON"\" \"" +
                    jalib::Filesystem::FindHelperUtility("preprocessor.py")
                    +"\"";

  args.param("input",      inputs).help("input file to compile (*.pbcc)");
  args.param("output",     theOutputBin).help("output binary to be produced");
  args.param("outputinfo", theOutputInfo).help("output *.info file to be produced");
  args.param("outputobj",  theObjectFile).help("output *.o file to be produced");
  args.param("runtimedir", theRuntimeDir).help("directory where petabricks.h may be found");
  args.param("libdir",     theLibDir).help("directory where libpbruntime.a may be found");
  args.param("preproc",    thePbPreprocessor).help("program to use as preprocessor");
  args.param("compile",    shouldCompile).help("disable the compilation step");
  args.param("link",       shouldLink).help("disable the linking step");
  args.param("main",       theMainName).help("transform name to use as program entry point");
  args.param("hardcode",   theHardcodedConfig).help("a config file containing tunables to set to hardcoded values");
  args.param("jobs",       theNJobs).help("number of gcc processes to call at once");

  if(args.param("version").help("print out version number and exit") ){
    std::cerr << PACKAGE " compiler (pbc) v" VERSION " " REVISION_LONG << std::endl;
    return 1;
  }

  args.finishParsing(inputs);

  if(inputs.empty() || args.needHelp()){
    std::cerr << "\n" PACKAGE " compiler (pbc) v" VERSION " " REVISION_SHORT << std::endl;
    std::cerr << "USAGE: " << argv[0] << " [OPTIONS] filename.pbcc" << std::endl;
    std::cerr << "run `" << argv[0] << " --help` for options" << std::endl;
    return 1;
  }

  JASSERT(inputs.size()==1)(inputs.size()).Text("expected exactly one input file");
  theInput = inputs.front();
  if(theRuntimeDir.empty()) theRuntimeDir = jalib::Filesystem::Dirname(jalib::Filesystem::FindHelperUtility("runtime/petabricks.h"));
  if(theLibDir    .empty()) theLibDir     = jalib::Filesystem::Dirname(jalib::Filesystem::FindHelperUtility("libpbruntime.a"));
  if(theOutputBin .empty()) theOutputBin  = jalib::Filesystem::Basename(theInput);
  if(theObjDir.empty())     theObjDir     = theOutputBin + ".obj";
  if(theOutputInfo.empty()) theOutputInfo = theOutputBin + ".info";
  if(theObjectFile.empty()) theObjectFile = theOutputBin + ".o";
  
  
  int rv = mkdir(theObjDir.c_str(), 0755);
  if(rv!=0 && errno==EEXIST)
    rv=0, errno=0;
  JASSERT(rv==0)(theObjDir).Text("failed to create objdir");
  
  if(!theHardcodedConfig.empty())
    CodeGenerator::theHardcodedTunables() = jalib::JTunableManager::loadRaw(theHardcodedConfig);

  JASSERT(jalib::Filesystem::FileExists(theInput))(theInput)
    .Text("input file does not exist");

  // PARSE:

  TransformListPtr t = parsePbFile(theInput.c_str());

  // COMPILE:

  for(TransformList::iterator i=t->begin(); i!=t->end(); ++i){
    (*i)->initialize();
    #ifdef DEBUG
    (*i)->print(std::cout);
    #endif
  }

  for(TransformList::iterator i=t->begin(); i!=t->end(); ++i){
    (*i)->compile();
  }

  findMainTransform(t);

  // CODEGEN:
  StreamTreePtr header = new StreamTree("header");
  StreamTreePtr prefix = header->add(new StreamTree("prefix"));
  CodeGenerator o(header, NULL);
  
  for(TransformList::iterator i=t->begin(); i!=t->end(); ++i){
    ccfiles.push_back(OutputCode(theObjDir+"/"+(*i)->name(), o));
    (*i)->generateCode(o);
  }

  // generate misc files:
  o.cg().beginGlobal();
#ifdef SINGLE_SEQ_CUTOFF
  o.createTunable(true, "system.cutoff.sequential", "sequentialcutoff", 64);
#endif
  o.cg().endGlobal();
  ccfiles.push_back(OutputCode(theObjDir+"/"GENMISC, o));
  o.outputTunables(o.os());
  o.comment("A hook called by PetabricksRuntime");
  o.beginFunc("petabricks::PetabricksRuntime::Main*", "petabricksMainTransform");
  o.write("return "+theMainName+"_main::instance();");
  o.endFunc();
  o.comment("A hook called by PetabricksRuntime");
  o.beginFunc( "petabricks::PetabricksRuntime::Main*"
             , "petabricksFindTransform"
             , std::vector<std::string>(1, "const std::string& name"));
  for(TransformList::iterator i=t->begin(); i!=t->end(); ++i){
    (*i)->registerMainInterface(o);
  }
  o.write("return NULL;");
  o.endFunc();
  
  // generate common header file:
  *prefix << headertxth;
  *prefix << "namespace { \n";
  *prefix << CodeGenerator::theFilePrefix().str();
  *prefix << "} \n";
  o.outputTunableHeaders(*prefix);
  ccfiles.writeHeader(header);

  // dump .info file:
  std::ofstream infofile(theOutputInfo.c_str());
  o.cg().dumpTo(infofile);
  infofile.flush();
  infofile.close();
  
  // COMPILE AND LINK:
  if(shouldCompile)
    ccfiles.compile();
  else
    ccfiles.write();

  if(shouldLink)
    ccfiles.link();

#ifdef DEBUG
  MAXIMA.sanityCheck();
#endif

  JTRACE("done")(theInput)(theOutputInfo)(theObjDir)(theOutputBin);
  return 0;
}


