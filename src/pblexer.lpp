%option stack
%option yylineno
%option nostdinit
%option noyywrap
%option nounput
%option prefix="pb"
%option outfile="lex.yy.c"

%{
#include "transform.h"
#include "rule.h"
#include "formula.h"
#include "matrixdef.h"
#include "jassert.h"
#include "jconvert.h"
#include "pbparser.h"
#include "codegenerator.h"
#include <stdio.h>
#include <string>
#include <sstream>

using namespace std;

#define NUM_STR_BUFFERS 64

static std::stringstream theParseLog;

static const char* circularStringCache(const char* str){
  static std::string strbuffers[NUM_STR_BUFFERS];
  static int n = 0;
  return (strbuffers[n++ % NUM_STR_BUFFERS]=str).c_str();
}

static void recordLitCode(){
  std::string str = theParseLog.str().c_str();
  theParseLog.str("");
  petabricks::CodeGenerator::theFilePrefix() << std::string(str.begin(), str.end()-2);
}

int rulebodystart=0;
std::string pbfilename;

static void handleCppLine(const char* s){
  const char* n_begin = s+2;
  const char* n_end = n_begin;
  while(*n_end>='0' && *n_end<='9') ++n_end;
  const char* filename=n_end+1;
  std::string n(n_begin, n_end);
  //JTRACE("LINENO")(n)(filename);
  pblineno = jalib::StringToInt(n)-1;
  pbfilename = filename;
}

#define YY_USER_ACTION pblval.str=circularStringCache(yytext); theParseLog<<yytext;
#define YY_DECL int yylex()
#define RETURN theParseLog.str(""); return

static int theNestCount=0;

%}

%x transform rule comment linecomment string litcode

PASS_CHARS [.<>,*/()[\]^+-]

%%
<INITIAL>{
  "main"           RETURN MAIN;
  "transform"      RETURN TRANSFORM;
  "template"       RETURN TEMPLATE;
  "generator"      RETURN GENERATOR;
  "gen"            RETURN GENERATOR;
  "through"        RETURN THROUGH;
  "testcase"       RETURN TESTCASE;
  "{"              yy_push_state(transform); RETURN '{';
  "%{"             yy_push_state(litcode); theParseLog.str("");
}

<litcode>{
  [^%]*            /*nothing*/
  [%][^}]          /*nothing*/
  "%}"             {
      yy_pop_state();
      recordLitCode();
  }
}

<transform>{
  "where"          RETURN WHERE;
  "priority"       RETURN PRIORITY;
  "primary"        RETURN PRIMARY;
  "secondary"      RETURN SECONDARY;
  "rotatable"      RETURN ROTATABLE;
  "recursive"      RETURN RECURSIVE;
  "{"              {
                     yy_push_state(rule); 
                     theNestCount=1; 
                     theParseLog.str("");
                     theParseLog << "# " << pblineno << " " << pbfilename << "\n";
                     return *yytext;
                   }
  "}"              yy_pop_state();      RETURN *yytext;
}

<INITIAL,transform>{
  "to"              RETURN TO;
  "from"            RETURN FROM;
  "<="              RETURN LE;
  ">="              RETURN GE;
  [0-9]+[.][0-9]+   RETURN FLOAT;
  [0-9]+            RETURN INTEGER;
  [a-zA-Z_][a-zA-Z0-9_]* RETURN IDENT;
  {PASS_CHARS}      RETURN yytext[0];
  [/][*]            yy_push_state(comment);
  [/][/]            yy_push_state(linecomment);
  ^[#]              yy_push_state(linecomment);
}

<rule>{
  [/][*]           yy_push_state(comment);
  [/][/]           yy_push_state(linecomment);
  ^[#]             yy_push_state(linecomment);
  "{"              ++theNestCount;
  ["]              yy_push_state(string);
  "}"              { 
                      if(--theNestCount==0){
                        yy_pop_state();
                        pblval.str=circularStringCache(theParseLog.str().c_str());
                        RETURN RULEBODY;
                      }
                   }
  [^*/{}"]+        /*nothing*/
  .                /*nothing*/
}

<comment>{
  "*/"             yy_pop_state();
  [^*]+            /*nothing*/
  .                /*nothing*/
}

<linecomment>{
  [\n]           yy_pop_state();
  [^\n]+         /*nothing*/
}

<string>{
  ["]            yy_pop_state();
  [^"]           /*nothing*/
  [\\]["]        /*nothing*/
}

<*>{
  ^[#][ ][0-9]+[ ][^\n]*   handleCppLine(yytext);
  [ \t\r\n]      /* whitespace */;
  .              JASSERT(false)(yytext)(yylineno).Text("Unhandled input");
}

%%


