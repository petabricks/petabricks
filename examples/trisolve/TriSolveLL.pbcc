#ifndef TRISOLVELL_PBCC
#define TRISOLVELL_PBCC

// Left lower (LL) triangular solve
// Solve AX = B for X, where A is lower triangular

#include "../simple/macros.h"
#include "../simple/copy.pbcc"
#include "../simple/transpose.pbcc"
#include "../simple/scale.pbcc"
#include "../multiply/multiplyAdd.pbcc"
//#include "TriSolveLAPACK.pbcc"
#include "TriSolveGenerators.pbcc"

transform TriSolveLLBase
from UNITFLAG, A[m,m]
to X[n,m]
{
    // greedy serial (IJK)
    to   (X x)
    from (UNITFLAG unitFlag, A a)
    {
        #ifdef PRINT
        printf("TriSolveLLBase (serial G IJK) (%d, %d)\n", m, n);
        #endif

        IndexT i, j, k;
        for (i = 0; i < m; ++i) {
            if (!unitFlag) {
                for (j = 0; j < n; ++j) {
                    x.cell(j, i) /= a.cell(i, i);
                }
            }
            for (j = 0; j < n; ++j) {
                for (k = i + 1; k < m; ++k) {
                    x.cell(j, k) -= a.cell(i, k) * x.cell(j, i);
                }
            }
        }
    }

    // lazy serial (IJK)
    to   (X x)
    from (UNITFLAG unitFlag, A a)
    {
        #ifdef PRINT
        printf("TriSolveLLBase (serial L IJK) (%d, %d)\n", m, n);
        #endif

        IndexT i, j, k;
        for (i = 0; i < m; ++i) {
            for (j = 0; j < n; ++j) {
                for (k = 0; k < i; ++k) {
                    x.cell(j, i) -= a.cell(k, i) * x.cell(j, k);
                }
            }
            if (!unitFlag) {
                for (j = 0; j < n; ++j) {
                    x.cell(j, i) /= a.cell(i, i);
                }
            }
        }
    }

    // greedy serial (IKJ)
    to   (X x)
    from (UNITFLAG unitFlag, A a)
    {
        #ifdef PRINT
        printf("TriSolveLLBase (serial G IKJ) (%d, %d)\n", m, n);
        #endif

        IndexT i, j, k;
        for (i = 0; i < m; ++i) {
            if (!unitFlag) {
                for (j = 0; j < n; ++j) {
                    x.cell(j, i) /= a.cell(i, i);
                }
            }
            for (k = i + 1; k < m; ++k) {
                for (j = 0; j < n; ++j) {
                    x.cell(j, k) -= a.cell(i, k) * x.cell(j, i);
                }
            }
        }
    }

    // lazy serial (IKJ)
    to   (X x)
    from (UNITFLAG unitFlag, A a)
    {
        #ifdef PRINT
        printf("TriSolveLLBase (serial L IKJ) (%d, %d)\n", m, n);
        #endif

        IndexT i, j, k;
        for (i = 0; i < m; ++i) {
            for (k = 0; k < i; ++k) {
                for (j = 0; j < n; ++j) {
                    x.cell(j, i) -= a.cell(k, i) * x.cell(j, k);
                }
            }
            if (!unitFlag) {
                for (j = 0; j < n; ++j) {
                    x.cell(j, i) /= a.cell(i, i);
                }
            }
        }
    }

#if 0
    // greedy (update trailing matrix after each row is solved)
    to   (X x)
    from (UNITFLAG unitFlag, A a)
    {
        #ifdef PRINT
        printf("TriSolveLLBase (G) (%d, %d)\n", m, n);
        #endif

        for (IndexT i = 0; i < m-1; ++i) {
            if (!unitFlag) {
                Scale1D(x.row(i), 1.0 / a.cell(i, i));
            }
            MatrixMultiplyAdd(x.region(0, i+1, n, m), -1,
                              a.region(i, i+1, i+1, m),
                              x.region(0, i, n, i+1), 1);
        }
        if (!unitFlag) {
            Scale1D(x.row(m-1), 1.0 / a.cell(m-1, m-1));
        }
    }

    // lazy (process one row at a time)
    to   (X x)
    from (UNITFLAG unitFlag, A a)
    {
        #ifdef PRINT
        printf("TriSolveLLBase (L) (%d, %d)\n", m, n);
        #endif

        if (!unitFlag) {
            Scale1D(x.row(0), 1.0 / a.cell(0, 0));
        }
        for (IndexT i = 1; i < m; ++i) {
            ElementT factor = unitFlag ? 1 : 1.0 / a.cell(i, i);
            MatrixMultiplyAdd(x.region(0, i, n, i+1), -factor,
                              a.region(0, i, i, i+1),
                              x.region(0, 0, n, i), factor);
        }
    }

    // call LAPACK
    to (X x)
    from (UNITFLAG unitFlag, A a) {
        #ifdef PRINT
        printf("TriSolveLLBase (LAPACK) (%d, %d)\n", m, n);
        #endif

        TriSolveLAPACK(x, 0, 0, unitFlag, 1, a);
    }
#endif
}

transform TriSolveLLBlocked
from UNITFLAG, A[m,m]
to X[n,m]
tunable sizespecific blockSize
{
    // greedy (update trailing matrix after each row block is solved)
    to   (X x)
    from (UNITFLAG unitFlag, A a)
    {
        if (blockSize < 1 || blockSize >= m) {
            TriSolveLLBase(x, unitFlag, a);
            return;
        }

        #ifdef PRINT
        printf("TriSolveLLBlocked (G) (%d, %d), %d\n", m, n, (int) blockSize);
        #endif

        MatrixRegion2D x1, x2;
        ConstMatrixRegion2D a11, a21, a22;

        x1 = x.region(0, 0, n, blockSize);
        x2 = x.region(0, blockSize, n, m);

        a11 = a.region(0, 0, blockSize, blockSize);
        a21 = a.region(0, blockSize, blockSize, m);
        a22 = a.region(blockSize, blockSize, m, m);

        TriSolveLLBase(x1, unitFlag, a11);
        MatrixMultiplyAdd(x2, -1, a21, x1, 1);
        TriSolveLLBlocked(x2, unitFlag, a22);
    }

    // lazy (process one row block at a time)
    to   (X x)
    from (UNITFLAG unitFlag, A a)
    {
        if (blockSize < 1 || blockSize >= m) {
            TriSolveLLBase(x, unitFlag, a);
            return;
        }

        #ifdef PRINT
        printf("TriSolveLLBlocked (L) (%d, %d), %d\n", m, n, (int) blockSize);
        #endif

        IndexT i0, i1;
        MatrixRegion2D x1, x2;
        ConstMatrixRegion2D a21, a22;

        for (i0 = 0; i0 < m; i0 += blockSize) {

            i1 = MIN(i0 + blockSize, m);

            x2  = x.region( 0, i0,  n, i1);
            a22 = a.region(i0, i0, i1, i1);

            if (i0 == 0) {
                TriSolveLLBase(x2, unitFlag, a22);
            } else {

                x1  = x.region(0,  0,  n, i0);
                a21 = a.region(0, i0, i0, i1);

                MatrixMultiplyAdd(x2, -1, a21, x1, 1);
                TriSolveLLBase(x2, unitFlag, a22);
            }
        }
    }
}

// split A into quadrants and solve recursively
transform TriSolveLLRecursive
from UNITFLAG, A[m,m]
to X[n,m]
tunable sizespecific blockSize
{
    // similar to greedy blocked version
    to   (X x)
    from (UNITFLAG unitFlag, A a)
    {
        if (blockSize < 1 || blockSize >= m) {
            TriSolveLLBlocked(x, unitFlag, a);
            return;
        }

        #ifdef PRINT
        printf("TriSolveLLRecursive (%d, %d), %d\n", m, n, (int) blockSize);
        #endif

        ConstMatrixRegion2D a11, a21, a22;
        MatrixRegion2D x1, x2;

        a11 = a.region(0  , 0  , m/2, m/2);
        a21 = a.region(0  , m/2, m/2, m  );
        a22 = a.region(m/2, m/2, m  , m  );

        x1 = x.region(0, 0  , n, m/2);
        x2 = x.region(0, m/2, n, m  );

        TriSolveLLRecursive(x1, unitFlag, a11);
        MatrixMultiplyAdd(x2, -1, a21, x1, 1);
        TriSolveLLRecursive(x2, unitFlag, a22);
    }
}

// split X into two and solve in parallel
transform TriSolveLLSplit
from UNITFLAG, A[m,m]
to X[n,m]
tunable sizespecific blockSize
{
    to   (X x)
    from (UNITFLAG unitFlag, A a)
    {
        if (blockSize < 1 || blockSize >= n) {
            TriSolveLLRecursive(x, unitFlag, a);
            return;
        }

        #ifdef PRINT
        printf("TriSolveLLSplit (%d, %d), %d\n", m, n, (int) blockSize);
        #endif
        MatrixRegion2D x1, x2;

        x1 = x.region(0  , 0, n/2, m);
        x2 = x.region(n/2, 0, n  , m);

        spawn TriSolveLLSplit(x1, unitFlag, a);
        spawn TriSolveLLSplit(x2, unitFlag, a);
        sync;
    }
}

transform TriSolveLLInPlace
from UNITFLAG, A[m,m]
to X[n,m]
{
    to (X x) from (UNITFLAG unitFlag, A a) {
        TriSolveLLSplit(x, unitFlag, a);
    }

#if 0
    to (X x) from (UNITFLAG unitFlag, A a) {
        TriSolveLLRecursive(x, unitFlag, a);
    }

    to (X x) from (UNITFLAG unitFlag, A a) {
        TriSolveLLBlocked(x, unitFlag, a);
    }

    to (X x) from (UNITFLAG unitFlag, A a) {
        TriSolveLLBase(x, unitFlag, a);
    }
#endif
}

transform TriSolveLL
from UNITFLAG, A[m,m], B[n,m]
to X[n,m]
generator TriSolveLGenerator
{
    to (X x) from (UNITFLAG unitFlag, A a, B b) {
        #ifdef PRINT
        printf("TriSolveLL No Transpose\n");
        #endif
        Copy2D(x, b);
        TriSolveLLInPlace(x, unitFlag, a);
    }

    to (X x) from (UNITFLAG unitFlag, A a, B b) {
        #ifdef PRINT
        printf("TriSolveLL Transpose\n");
        #endif
        MatrixRegion2D t = MatrixRegion2D::allocate(m,n);
        Transpose(t, b);
        TriSolveLLInPlace(t.transposed(), unitFlag, a);
        Transpose(x, t);
    }
}

#endif // TRISOLVELL_PBCC
