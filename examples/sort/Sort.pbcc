#ifndef SORT_PBCC
#define SORT_PBCC

#define SORTSUBARRAY SortSubArray
#include "Quicksort.pbcc"
#include "Insertionsort.pbcc"
//#include "Radixsort.pbcc"
#include "Parallel_Mergesort.pbcc"

#define WAY 4
#include "Mergesort.pbcc"
#undef WAY

#define WAY 8
#include "Mergesort.pbcc"
#undef WAY

#define WAY 16
#include "Mergesort.pbcc"
#undef WAY

transform SortSubArray
from IN[n], Pos
to OUT[n], TEMP[n]
{
  recursive(n)
  to (OUT out, TEMP temp) from (IN in, Pos p)
  {
    //printf("ms %d\n",n);
    SPAWN(Parallel_MergesortSubArray, out, temp, in, p);
  }

  recursive(n)
  to (OUT out, TEMP temp) from (IN in, Pos p)
  {
    //printf("ms %d\n",n);
    SPAWN(MergesortSubArray4,out, temp, in, p);
  }

  recursive(n)
  to (OUT out, TEMP temp) from (IN in, Pos p)
  {
    //printf("ms %d\n",n);
    SPAWN(MergesortSubArray8,out, temp, in, p);
  }
  
  recursive(n)
  to (OUT out, TEMP temp) from (IN in, Pos p)
  {
    //printf("ms %d\n",n);
    SPAWN(MergesortSubArray16,out, temp, in, p);
  }

  recursive(n)
  to (OUT out, TEMP temp) from (IN in, Pos p)
  {
    //printf("qs %d\n",n);
    SPAWN(QuicksortSubArray,out, temp, in, p);
  }

//recursive(n)
//to (OUT out, TEMP temp) from (IN in, Pos p)
//{
//  //printf("rs %d\n",n);
//  SPAWN(RadixsortSubArray,out, temp, in, p);
//}

  to (OUT out, TEMP temp) from (IN in)
  {
    //printf("is %d\n",n);
    InsertionsortSubArray(out, in);
  }
}

transform Sort
from IN[n]
to OUT[n]
{
  to (OUT out) from (IN in)
  {
    Copy1D(out, in);
    MatrixRegion1D temp = MatrixRegion1D::allocate(n);
    SortSubArray(out, temp, in, 60);
  }
}

#endif // SORT_PBCC

