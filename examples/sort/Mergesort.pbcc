#ifndef MERGESORT_PBCC
#define MERGESORT_PBCC

#include "../utilities.pbcc"

#ifndef SORTSUBARRAY
#define SORTSUBARRAY MergesortSubArray
#endif

transform Merge
from IN[n]
to OUT[n]
{
  to (OUT out) from (IN in)
  {
    int middle = n / 2, ptr1 = 0, ptr2 = middle;
    for (int i = 0; i < n; i++) {
      if (ptr2 == n || ptr1 < middle && in.cell(ptr1) < in.cell(ptr2)) {
        out.cell(i) = in.cell(ptr1++);
      } else {
        out.cell(i) = in.cell(ptr2++);
      }
    }
  }
}

transform MergesortSubArray
from IN[n], Pos
to OUT[n], TEMP[n]
{
  recursive to(OUT out, TEMP temp) from (IN in, Pos p)
  {
    int left=0;
    int right=n-1;
    int middle = (left + right + 1) / 2;

    if (middle - left > 1)
      SPAWN(SORTSUBARRAY,out .region(0,middle),
                         temp.region(0,middle),
                         in  .region(0,middle), p);
    if (right - middle > 0)
      SPAWN(SORTSUBARRAY,out .region(middle,n),
                         temp.region(middle,n),
                         in  .region(middle,n), p);
    
    SYNC();
    SPAWN(Copy1D,temp.region((int) left, (int) right + 1), out.region((int) left, (int) right + 1));
    SYNC();
    SPAWN(Merge,out.region((int) left, (int) right + 1), temp.region((int) left, (int) right + 1));
  }
}

transform Mergesort
from IN[n]
to OUT[n]
{
  to(OUT out) from (IN in)
  {
    Copy1D(out, in);
    MatrixRegion1D temp = MatrixRegion1D::allocate(n);
    MergesortSubArray(out, temp, in, 60);
  }
}

#endif // MERGESORT_PBCC

