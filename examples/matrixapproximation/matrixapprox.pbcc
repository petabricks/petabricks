#ifndef MATRIXAPPROX_PBCC
#define MATRIXAPPROX_PBCC

//#ifndef k
//#define k 4
//#endif

#include "../multiply/multiply.pbcc"
#include "../simple/copy.pbcc"
#include "../eigenproblem/EigSym.pbcc"
#include "../simple/transpose.pbcc"
#include "Bisection.pbcc"

main transform MatrixApprox
//param k  //input param: number of singular values used k<=n
from IN[n,n]
through Lambda[2*n], X[2*n,2*n], U[n,n], VT[n,n], H[2*n,2*n], TEMP[n,n]
to OUT[n,n]
accuracy_metric Norm
accuracy_bins 0, 0.2, 0.4, 0.6, 0.8, 1
accuracy_variable k(1,1,n-1) //min=1, initial=1, max=n-1
generator matrixapproinputgen
{


	to (H.region(n,0,2*n,n) h) from (IN a) {
		Transpose(h, a);
	}
	to (H.region(0,n,n,2*n) h )from (IN a){
		Copy2D(h, a);
	}
	secondary H.cell(i,j) from() {
		return 0;
	}

	// use optimized hybrid algorithm to find all eigenvalues/eigenvectors
        to (Lambda lam, X x) from (H h){
                EigSym(lam, x, h);
        }

	// find only the k eigenvalues/eigenvectors by Bisection method
	to (Lambda lam, X x) from (H h) {
		Bisection(lam,x,h,k);
	}

//	Sigma.cell(i) from (Lambda.cell(i) lam) {
//		return -lam;
//	}

//      U.cell(i,j) from (X.cell(i,j+n) x){
//              return -sqrt(2)*x;
//      }

	//combine sigma(k) * U(k)
	U.cell(i,j) from (X.cell(i,j+n) x, Lambda.cell(i) lam){
		return lam*sqrt(2)*x;
	}

	//V tranposed
	VT.cell(j,i) from (X.cell(i,j) x){
		return sqrt(2)*x;	
	}
		


	to (OUT out, TEMP temp) from (U u, VT vt){
		int i;
		MatrixMultiply(out, u.region(0,0,1,n), vt.region(0,0,n,1) );
		for (i=1; i<k; i++) { //forenough?
			//MatrixAdd(out, out, MatrixMultiply(u.region(i,0,i+1,n), vt.region(0,i,n,i+1)) );
			MatrixMultiply(temp, u.region(i,0,i+1,n), vt.region(0,i,n,i+1));
			MatrixAdd(out, out, temp);
		}
	} 
}

transform Norm
from OUT[n,n], IN[n,n]
to Accuracy
{
	//accuracy measure
	Accuracy  from(IN in, OUT out) 
	{
		int i;
		int j;
		ElementT sum=0;
		for (i=0; i<n; i++) {
			for (j=0; j<n; j++) {
				sum+=fabs(in.cell(i,j)-out.cell(i,j));
			}
		}
		sum=sum/n/n;
		return -log10(sum);
	}
			
}

transform matrixapproinputgen
to IN[n,n]
{
  //todo... we need something better than this
  IN.cell(i,j) from() { return PetabricksRuntime::randDouble(0,1); }
}


#endif // MATRIXAPPROX_PBCC
