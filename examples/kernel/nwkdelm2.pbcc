#ifndef NWKDELM2_PBCC
#define NWKDELM2_PBCC

#include "utils.pbcc"
#include "nwkde.pbcc"

#define DEBUG
//#define WORKAROUND // workaround for generator having specific sizes

transform NWKDELM2
#ifdef WORKAROUND
from TRAINDATA[4,n], WRAPFLAGS[4], KERNELWIDTHS[4],
     TRAININDICES[n-2], TRAINVARINDEX[8], TRAINTIMEOFFSET[8],
     TESTDATA[4,n],
     TESTINDICES[n-2], TESTVARINDEX[8], TESTTIMEOFFSET[8],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET
to RESULT[n-2]
through SQDIFFS[8,n-2,n-2], WEIGHTS[n-2,n-2], PARTIALS[n-2,n-2], INPUTSCHECKED
#else
from TRAINDATA[m,n], WRAPFLAGS[m], KERNELWIDTHS[m],
     TRAININDICES[l], TRAINVARINDEX[p], TRAINTIMEOFFSET[p],
     TESTDATA[m2,n2],
     TESTINDICES[q], TESTVARINDEX[p], TESTTIMEOFFSET[p],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET
to RESULT[q]
through INPUTSCHECKED
#endif
generator NWKDEGenerator
//optimize KERNELWIDTHS[m]
{
    INPUTSCHECKED
    from (TRAININDICES trainIndices,
          TRAINVARINDEX trainVarIndex,
          TRAINTIMEOFFSET trainTimeOffset,
          TESTINDICES testIndices,
          TESTVARINDEX testVarIndex,
          TESTTIMEOFFSET testTimeOffset,
          OUTPUTVARINDEX outputVarIndex,
          OUTPUTTIMEOFFSET outputTimeOffset)
    {
#ifdef DEBUG
        double min, max, min2, max2;

#ifdef WORKAROUND
        int m = 4, m2 = 4, n2 = 10;
#endif

        findMinAndMax(&min, &max, trainVarIndex);
        printf("trainVarIndex range: (%g, %g)\n", min, max);
        if (min < 0 || max > m) {
            printf("trainVarIndex out of bounds: (%d, %d)\n", 0, m);
            PetabricksRuntime::abort();
        }

        printf("outputVarIndex: %g\n", outputVarIndex);
        if (outputVarIndex < 0 || outputVarIndex > m) {
            printf("outputVarIndex out of bounds: (%d, %d)\n", 0, m);
            PetabricksRuntime::abort();
        }

        findMinAndMax(&min, &max, testVarIndex);
        printf("testVarIndex range: (%g, %g)\n", min, max);
        if (min < 0 || max > m2) {
            printf("testVarIndex out of bounds: (%d, %d)\n", 0, m2);
            PetabricksRuntime::abort();
        }

        findMinAndMax(&min, &max, trainIndices);
        findMinAndMax(&min2, &max2, trainTimeOffset);
        printf("trainIndices + trainTimeOffset range: (%g, %g)\n",
               min + min2, max + max2);
        if (min + min2 < 0 || max + max2 > n) {
            printf("trainIndices + trainTimeOffset out of bounds: (%d, %d)\n",
                   0, n);
            PetabricksRuntime::abort();
        }

        printf("trainIndices + outputTimeOffset range: (%g, %g)\n",
               min + outputTimeOffset, max + outputTimeOffset);
        if (min + outputTimeOffset < 0 || max + outputTimeOffset > n) {
            printf("trainIndices + outputTimeOffset out of bounds: (%d, %d)\n",
                   0, n);
            PetabricksRuntime::abort();
        }

        findMinAndMax(&min, &max, testIndices);
        findMinAndMax(&min2, &max2, testTimeOffset);
        printf("testIndices + testTimeOffset range: (%g, %g)\n",
               min + min2, max + max2);
        if (min + min2 < 0 || max + max2 > n2) {
            printf("testIndices + testTimeOffset out of bounds: (%d, %d)\n",
                   0, n2);
            PetabricksRuntime::abort();
        }
#endif // DEBUG

        return 0;
    }

    RESULT.cell(k)
    from (TRAINDATA trainData,
          WRAPFLAGS wrapFlags,
          KERNELWIDTHS kernelWidths,
          TRAININDICES trainIndices,
          TRAINVARINDEX trainVarIndex,
          TRAINTIMEOFFSET trainTimeOffset,
          TESTDATA testData,
          TESTINDICES.cell(k) testIndex,
          TESTVARINDEX testVarIndex,
          TESTTIMEOFFSET testTimeOffset,
          OUTPUTVARINDEX outputVarIndex,
          OUTPUTTIMEOFFSET outputTimeOffset)
    {
        double result = 0, totalWeight = 0;

        for (int j = 0; j < trainIndices.count(); ++j) {

            int trainIndex = (int) trainIndices.cell(j);

            double sum = 0, weight;

            for (int i = 0; i < trainVarIndex.count(); ++i) {

                int wrapFlag = (int) wrapFlags.cell((int) trainVarIndex.cell(i));
                double kernelWidth = kernelWidths.cell((int) trainVarIndex.cell(i));

                int trainTimeIndex = (int) trainIndex + (int) trainTimeOffset.cell(i);
                int  testTimeIndex = (int)  testIndex + (int)  testTimeOffset.cell(i);

                double trainPoint = trainData.cell((int) trainVarIndex.cell(i), trainTimeIndex);
                double  testPoint =  testData.cell((int)  testVarIndex.cell(i),  testTimeIndex);

#ifdef DEBUG
                if (trainPoint == -1) {
                    trainPoint = NAN;
                }
                if (testPoint == -1) {
                    testPoint == NAN;
                }
#endif // DEBUG

                double diff = trainPoint - testPoint;

                if (wrapFlag) {

                    // wrap relative difference into [-180,180]
                    // do most of the arithmetic in integers for speed
                    // P360 and M360 indicate "plus 360" and "minus 360"

                    // add 360 *before* cast to round towards -INF instead of towards 0
                    int diffIntP360 = (int) (diff + 360);

                    // add 180 to ensure modulo result is positive
                    int diffIntWrapP360 = ((diffIntP360 + 180) % 360) + 180;

                    double diffFracM360 = diff - diffIntP360;
                    diff = diffIntWrapP360 + diffFracM360;
                }

                // normalize according to kernel width
                diff /= kernelWidth;

                // return squared difference
                sum += diff * diff;
            }

            weight = exp(-((double) sum));
            totalWeight += weight;

            int outputTimeIndex = (int) trainIndex + (int) outputTimeOffset;
            result += trainData.cell((int) outputVarIndex, outputTimeIndex) * weight;
        }

        result /= totalWeight;
#ifdef DEBUG
//        printf("Output %d = %g\n", k, result);
#endif // DEBUG
        return result;
    }
}

#endif // NWKDELM_PBCC

