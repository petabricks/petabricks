#ifndef NWKDELM_PBCC
#define NWKDELM_PBCC

#include "utils.pbcc"
#include "nwkde.pbcc"

#define DEBUG
#define WORKAROUND // workaround for generator having specific sizes

transform NWKDELM
#ifdef WORKAROUND
from TRAINDATA[4,8750], WRAPFLAGS[4], KERNELWIDTHS[4],
     TRAININDICES[l], TRAINVARINDEX[8], TRAINTIMEOFFSET[8],
     TESTDATA[4,8750],
     TESTINDICES[q], TESTVARINDEX[8], TESTTIMEOFFSET[8],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET
to RESULT[q]
through WEIGHTS[l,q], PARTIALS[l,q], INPUTSCHECKED
#else
from TRAINDATA[m,n], WRAPFLAGS[m], KERNELWIDTHS[m],
     TRAININDICES[l], TRAINVARINDEX[p], TRAINTIMEOFFSET[p],
     TESTDATA[m2,n2],
     TESTINDICES[q], TESTVARINDEX[p], TESTTIMEOFFSET[p],
     OUTPUTVARINDEX, OUTPUTTIMEOFFSET
to RESULT[q]
through WEIGHTS[l,q], PARTIALS[l,q], INPUTSCHECKED
#endif
generator NWKDEGenerator
//optimize KERNELWIDTHS[m]
{
    INPUTSCHECKED
    from (TRAININDICES trainIndices,
          TRAINVARINDEX trainVarIndex,
          TRAINTIMEOFFSET trainTimeOffset,
          TESTINDICES testIndices,
          TESTVARINDEX testVarIndex,
          TESTTIMEOFFSET testTimeOffset,
          OUTPUTVARINDEX outputVarIndex,
          OUTPUTTIMEOFFSET outputTimeOffset)
    {
#ifdef DEBUG
        NWKDECheckInputs(trainIndices, trainVarIndex, trainTimeOffset,
                          testIndices,  testVarIndex,  testTimeOffset,
                         outputVarIndex, outputTimeOffset);
#endif
        return 0;
    }

    WEIGHTS.cell(j,k)
    from (TRAINDATA trainData,
          WRAPFLAGS wrapFlags,
          KERNELWIDTHS kernelWidths,
          TRAININDICES.cell(j) trainIndex,
          TRAINVARINDEX trainVarIndex,
          TRAINTIMEOFFSET trainTimeOffset,
          TESTDATA testData,
          TESTINDICES.cell(k) testIndex,
          TESTVARINDEX testVarIndex,
          TESTTIMEOFFSET testTimeOffset)
    {
        double sum = 0;

        for (int i = 0; i < trainVarIndex.count(); ++i) {

            int wrapFlag = (int) wrapFlags.cell((int) trainVarIndex.cell(i));
            double kernelWidth = kernelWidths.cell((int) trainVarIndex.cell(i));

            int trainTimeIndex = (int) trainIndex + (int) trainTimeOffset.cell(i);
            int  testTimeIndex = (int)  testIndex + (int)  testTimeOffset.cell(i);

            double trainPoint = trainData.cell((int) trainVarIndex.cell(i), trainTimeIndex);
            double  testPoint =  testData.cell((int)  testVarIndex.cell(i),  testTimeIndex);

#ifdef DEBUG
            if (trainPoint == -1) {
                trainPoint = NAN;
            }
            if (testPoint == -1) {
                testPoint == NAN;
            }
#endif // DEBUG

            double diff = trainPoint - testPoint;

            if (wrapFlag) {

                // wrap relative difference into [-180,180]
                // do most of the arithmetic in integers for speed
                // P360 and M360 indicate "plus 360" and "minus 360"

                // add 360 *before* cast to round towards -INF instead of towards 0
                int diffIntP360 = (int) (diff + 360);

                // add 180 to ensure modulo result is positive
                int diffIntWrapP360 = ((diffIntP360 + 180) % 360) + 180;

                double diffFracM360 = diff - diffIntP360;
                diff = diffIntWrapP360 + diffFracM360;
            }

            // normalize according to kernel width
            diff /= kernelWidth;

            // return squared difference
            sum += diff * diff;
        }

        return exp(-((double) sum));
    }

    to (PARTIALS.cell(j,k) partial)
    from (TRAINDATA trainData,
          TRAININDICES.cell(j) trainIndex,
          OUTPUTVARINDEX outputVarIndex,
          OUTPUTTIMEOFFSET outputTimeOffset,
          WEIGHTS.cell(j,k) weight)
    {
        int timeIndex = (int) trainIndex + (int) outputTimeOffset;
        partial = trainData.cell((int) outputVarIndex, timeIndex);
        partial *= weight;
    }

    to (RESULT.cell(k) result)
    from (PARTIALS.row(k) partials,
          WEIGHTS.row(k) weights,
          INPUTSCHECKED checkDummy)
    {
        double totalWeight;
        ReduceAdd(result, partials);
        ReduceAdd(totalWeight, weights);
        result /= totalWeight;
#ifdef DEBUG
        printf("Output %d = %g\n", k, result);
#endif // DEBUG
    }
}

#endif // NWKDELM_PBCC

