#ifndef LU_PBCC
#define LU_PBCC

#include "../multiply/multiplyAdd.pbcc"
#include "../trisolve/TriSolveLL.pbcc"
#include "../simple/permute.pbcc"
#include "LUBase.pbcc"

transform LUGenerator
to OUT[n,n]
{
    to (OUT.cell(j, i) out)
    from ()
    {
        out = PetabricksRuntime::randNormal(0, 1);
    }
}

transform LUBlock
to A[n,m], P[m]
tunable sizespecific nb
{
    // right looking
    to (A a, P p) from ()
    {
        //base case
        if (nb < 1 || nb >= MIN(m,n)) {
            LUBaseInPlace(a, p);
            return;
        }

        // compute LU of left block
        LUBaseInPlace(a.region(0, 0, nb, m), p);

        // swap rows in right block
        PermuteInPlace(a.region(nb, 0, n, m), p);

        // upper right block
        TriSolveLLInPlace(a.region(nb, 0, n , nb), 1,
                          a.region(0 , 0, nb, nb));

        // update lower right block
        MatrixMultiplyAdd(a.region(nb, nb, n , m ), -1.0,
                          a.region(0 , nb, nb, m ),
                          a.region(nb, 0 , n , nb), 1.0);

        // compute LU of the updated lower right block
        LUInPlace(a.region(nb, nb, n, m), p.region(nb, m));

        // swap rows in lower left block
        PermuteInPlace(a.region(0, nb, nb, m), p.region(nb, m));

        // adjust permutation values to larger matrix
        for (IndexT i = nb; i < m; ++i) {
            p.cell(i) += nb;
        }
    }
}

transform LUInPlace
to A[n,m], P[m]
{
    to (A a, P p) from ()
    {
        LUBlock(a, p);
    }

    to (A a, P p) from ()
    {
        LUBaseInPlace(a, p);
    }
}

transform LU
from IN[n,m]
to OUT[n,m], P[m]
generator LUGenerator
{
    to (OUT out, P p) from (IN in)
    {
        Copy2D(out, in);
        LUInPlace(out, p);
    }
}

#endif // LU_PBCC
